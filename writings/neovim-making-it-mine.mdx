---
title: 'Neovim: Making It Mine'
date: '16-05-2025'
summary: "My personal Neovim setup: stripping it down, beefing it up, and making it actually work for me. Here's how my init.lua ticks."
ogImage: '/og/nvim-2025.png'
tags: ["nvim", "neovim", "dotfiles", "lua", "setup", "productivity", "editor"]
---

> Neovim out of the box? A bit like a wild horse. Powerful, sure, but it needs some serious taming before it's rideable. This is how I did it.

My Neovim configuration is all about control and efficiency. No fluff, just the tools I need to get things done without the editor getting in my way. The goal is a fast, intuitive environment that feels like an extension of my thoughts. You can find the [complete configuration in my dotfiles repository](https://github.com/dan10ish/dotfiles/blob/master/nvim/init.lua).

## Laying the Foundation: Packer & Core Settings

Plugin management is handled by [Packer.nvim](https://github.com/wbthomason/packer.nvim). It's a solid choice that keeps things organized. A simple autocommand ensures that any changes to my `init.lua` (like adding a new plugin) automatically trigger a sync, so I'm always up to date without thinking about it.

```lua
-- Packer.nvim: Ensuring it's installed and listing plugins
-- An autocommand group handles `PackerSync` on `init.lua` write.
require('packer').startup(function(use)
  use 'wbthomason/packer.nvim' -- Packer itself
  use 'neovim/nvim-lspconfig'  -- LSP configuration
  use 'hrsh7th/nvim-cmp'       -- Autocompletion
  -- ... other essential plugins like Telescope, Treesitter, etc.
end)
```

For Neovim's own settings, the focus is on a clean and predictable editing experience. Relative line numbers, for instance, are a game-changer for quick vertical navigation with count-prefixed commands. Using spaces instead of actual tab characters (`expandtab`) avoids a lot of cross-editor headaches. And, of course, integrating with the system clipboard (`unnamedplus`) is a must for practical yank and paste operations. My leader key is `<Space>` â€“ it's accessible and doesn't clash with common shortcuts.

```lua
-- A few key Neovim settings
vim.opt.relativenumber = true     -- Navigate by line offset easily
vim.opt.tabstop = 2             -- Tabs are visually 2 spaces
vim.opt.expandtab = true        -- Insert spaces when Tab key is pressed
vim.opt.clipboard = 'unnamedplus' -- Share clipboard with the OS
vim.g.mapleader = ' '           -- Leader key set to Space
```

## Aesthetics: Transparency

A touch of transparency helps Neovim integrate visually with my terminal setup, making it feel less like a separate, heavy application and more like a lightweight component of my workspace. This is achieved by telling Neovim to not draw a background for key UI elements like the main text area (`Normal`) or the NvimTree file explorer, letting my terminal's own transparency shine through.

```lua
-- Making select UI elements transparent
vim.cmd [[
  augroup TransparentNvim
    autocmd!
    autocmd ColorScheme * highlight Normal guibg=NONE ctermbg=NONE
    " ... similar highlights for NormalNC, NvimTreeNormal, etc. ...
  augroup END
]]
```

## Brains of the Operation: LSP, Completion, and Formatting

Modern coding heavily relies on Language Server Protocol (LSP) for features like go-to-definition, finding references, and inline diagnostics (errors/warnings). `nvim-lspconfig` is the backbone for setting this up. Autocompletion gets a massive boost with `nvim-cmp`, which intelligently suggests completions from various sources, including the LSP and `LuaSnip` for boilerplate or repetitive code snippets. This drastically reduces typing and typos.

To keep code neat and consistent without manual effort, `null-ls.nvim` integrates formatters like Prettier. It's configured to automatically format my code every time I save a file. This is a huge timesaver and ensures consistency, especially when working in teams.

```lua
-- LSP: Setting up a language server (e.g., pyright for Python)
require('lspconfig')['pyright'].setup {
  capabilities = require('cmp_nvim_lsp').default_capabilities(),
  -- ... other server-specific settings ...
}

-- nvim-cmp: Autocompletion setup essentials
require('cmp').setup({
  snippet = { expand = function(args) require('luasnip').lsp_expand(args.body) end },
  sources = { { name = 'nvim_lsp' }, { name = 'luasnip' }, { name = 'buffer' } },
  mapping = { ['<CR>'] = require('cmp').mapping.confirm({ select = false }) /* ... more ... */ },
})

-- null-ls: Auto-formatting with Prettier on save
require('null-ls').setup({
  sources = { require('null-ls').builtins.formatting.prettier },
  on_attach = function(client, bufnr) -- Triggers format on save
    if client.supports_method("textDocument/formatting") then
      vim.api.nvim_create_autocmd("BufWritePre", { /* ... details ... */ })
    end
  end,
})
```

Preview:

![terminal](/writing-assets/LSP.png)

## Navigation and Utility: Key Mappings & Essential Plugins

Efficiently moving around and interacting with my projects is key. `nvim-tree.lua` provides a familiar file explorer panel, quickly toggled with `<leader>e`, for a bird's-eye view of the project structure. For finding things, `telescope.nvim` is an absolute powerhouse. It does much more than just find files (`<leader>ff`); its live grep (`<leader>fg`) is incredibly fast for searching content across the entire project, with previews to boot. It can also search through open buffers, help tags, and more.

Commenting code quickly is handled by `Comment.nvim` (`<leader>/`), and `which-key.nvim` is a subtle but brilliant helper: it displays available keybindings after I press the leader key, which is great for discoverability and learning new mappings.

```lua
-- Example Key Mappings
local keymap_set = vim.keymap.set
keymap_set('n', '<leader>e', ':NvimTreeToggle<CR>')      -- Toggle file explorer
keymap_set('n', '<leader>ff', ':Telescope find_files<CR>') -- Find files with Telescope
keymap_set('n', '<C-h>', '<C-w>h')                      -- Navigate window splits
```

Preview:

![terminal](/writing-assets/FileGrep.png)

## Pretty Code: Treesitter

For syntax highlighting that actually understands the code's structure, not just matching keywords with regex, `nvim-treesitter` is essential. It parses the code into a syntax tree, leading to more accurate highlighting, better indentation, and enabling more advanced text objects and navigation in the future. I have it set to auto-install parsers for the languages I commonly work with.

```lua
-- nvim-treesitter: Ensuring parsers and enabling features
require('nvim-treesitter.configs').setup {
  ensure_installed = { "lua", "python", "javascript", "html", "css" /* ... more ... */ },
  auto_install = true,
  highlight = { enable = true },
  indent = { enable = true },
}
```

## Final Thoughts

This setup is lean, mean, and tailored to how I work. It didn't happen overnight; it's the result of countless tweaks and a drive to make Neovim a genuinely productive and enjoyable environment for me. It's proof that even the wildest, most intimidating tools can be tamed with a bit of Lua and patience, transforming them into powerful allies.

> Maybe Neovim doesn't entirely suck after all. With the right tweaks, it's pretty sharp.

Preview in the [Ghostty](https://ghostty.org) terminal

![terminal](/writing-assets/Overall.png)

Preview in Mac's default Terminal app.

![terminal](/writing-assets/MacTerminal.png)
